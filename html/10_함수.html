<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>함수</title>
		<link rel="shortcut icon" href="#" type="image/x-icon">
</head>
<body>
    <h1>함수</h1>
	- 코드를 저장 할 수 있는 수단 <br>
	- function이라는 키워드로 선언하여 코드를 저장한다. <br>
	- 함수를 호출을 하려면 먼저 선언이 되어 있어야 호출이 가능하다. <br>
	- 자바스크립트 함수는 익명함수와 일반함수가 있다.<br>
	- 함수 실행은 함수명 혹은 참조변수 (); -> 함수 실행
	
	<h2>함수 선언</h2>
	- 함수 선언 후에 {} -> 스코프 (블럭, 유효범위) <br>
	- 함수는 지역변수와 전역변수의 차이가 확실하다. <br>
	
	<h3>일반함수</h3>
	- 일반함수는 호이스팅 기술을 지원한다.<br>
	(아래에 함수가 선언이 되어 있더라도 위에서 호출 가능)
	
  <h3>일급함수</h3>
	- 일급함수는 함수를 다른 함수에 매개변수로 전달이 가능하거나, 변수에도 할당이 가능한 함수이다.<br>
  (변수에 담을 수 있고, 인자나 값으로도 사용이 가능하다)

	<script type="text/javascript">
		// 일반함수 선언 function 함수명(){}
		function fn1() {
			console.log('일반함수 선언문');
		}
		// 익명함수 변수선언키워드 변수명 = function(){}
		const fn2 = function () {
			console.log('익명함수 표현식');
		}
		// 화살표 함수 변수선언키워드 변수명 = (매개변수) => {};
		// 화살표 함수 변수선언키워드 변수명 = x => {};
		const arrowFn = () => {
			console.log('화살표함수');
			// 코드 ....
		}
		const fn3 = () => console.log('화살표함수');

	</script>
	
	<h3>익명함수</h3>
	- 익명함수는 대입을 해야 선언이 가능하다. <br>
	- 익명함수는 위에서 선언이 되어 있어야 아래서 호출이 가능하다.(호이스팅 기술 x)
	<script type="text/javascript">
		const fn4 = function () {
			console.log('익명함수 선언');
		}
		const arrowFn2 = x => console.log(x);
		const copyFn = fn4;
		console.log({copyFn});
		console.log({fn4});

	</script>
	
	<h2>함수 호출</h2>
	- 함수 내에 저장된 코드를 필요 할때마다 호출하여 코드를 실행시킨다.
	<script type="text/javascript">
		// 평가 시점에 function 키워드 호이스팅 대상이기 때문에 위 아래 상관없이 호출가능
		fn5();
		function fn5() {
			console.log('fn5 함수 호출');
		}
		fn5();
		// 익명함수 호출
		// fn6();
		console.log(typeof fn6)
		var fn6 = function () {
			console.log('fn6 함수 호출')
		}
		console.log(typeof fn6);
		fn6();

		const arrowFn3 = () => console.log('arrowFn3 호출');
		arrowFn3();
	</script>
	
	
	<h2>매개변수</h2>
	- 함수 호출시 인수를 삽입하여 호출할 수 있다. <br>
	- 함수 내부에서 인자 값을 받을때 매개변수로 받는다.<br>
	- 함수 호출시 함수를 인수로 받아 매개변수에 할당된 함수를 호출할 수 있다.
    
	<script type="text/javascript">
		function sum (x,y) {
			console.log(arguments);
			let result = x+y;
			console.log(`${x}와${y}의 두수의 합은 ${result}입니다. `)
		}
		sum(1,2);

		function sumFn(...arguments) {
			let result = 0;

			for (const arg of arguments) {
				result += arg;
			}

			console.log(arguments);
			console.log(`${result}`);
		}

		sumFn(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		sumFn(5, 6, 7, 8);

		//callback 함수
		//파라미터로 전달받은 함수
		function callbackFn(fn) {
			let name = '황병찬';
			fn(name);
		}
		callbackFn(function (name){
			console.log(`누나 왈 ${name} 이거 맞아?`);
		})

	</script>
	
	<h2>return</h2>
	- 함수 내에서 쓰일 수 있는 키워드 <br>
	- 함수를 호출 하는곳에 값을 전달 할 수 있다. <br>
	- 함수를 강제 종료 한다. <br>
	<script type="text/javascript">
		function subNum() {
			let result = 0;
			// return; 함수 종료시 키워드 return
			for (const arg of arguments) {
				result -= arg;
			}
			console.log(arguments);
			console.log(`${result}`);
			return result;
		}
		subNum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		subNum(5, 6, 7, 8);
		console.log(subNum(1, 2, 6, 7, 8));

	</script>
	
	<h2>함수 return</h2>
  <h3>고차함수</h3>
   - 고차함수: 함수를 반환하는 함수를 말한다.
	<script type="text/javascript">
		function fn7() {
			let name = '박준철';
			return function () {
				console.log(name);
			}
		}
		fn7()();
		const fn7resultFn = fn7();
		//console.log(fn7());

		function fn8() {
			let name = '조효미';
			const memberInfo = {};
			memberInfo.name = name;
			return memberInfo;
		/*	return {
				'name' : name
			} */
		}
		console.log(fn8());
	</script>
	
	<h2>내부 함수</h2>
	- 함수 내의 함수
	<script type="text/javascript">
		function otterFn() {
			innerFn();
			function innerFn() {
				console.log('innerFn 함수 호출')
			}
			innerFn();
		}
		otterFn();

		/* scope 정적 vs 동적 javascript 는 정적스코프 */
		// 정적: 함수를 어디에서 정의했는지?
		// 동적: 함수를 어디에서 호출했는지?
		var x = 20;
		function lexicalFn() {
			var x = 10;
			callFn();
		}
		function callFn() {
			console.log(x);
		}
		lexicalFn();
	</script>

  <h1>함수 - 재귀호출</h1>
	- 함수 내부에서 나 자신을 호출 
	<script type="text/javascript">
		function exFn(n) {
			if(n < 10) {
				console.log(`${n}번 호출`);
				return exFn(++n);
			}
			return n-1;
		}
		console.log(exFn(0));

		function factorial(n) {
			if (n === 0)
				return 1;
			return n * factorial(n - 1);
		}
		console.log(factorial(5));
		// 실습 문제 깊은 복사 재귀호출을 이용해서 복사하시오
		const arr1 = [100, 200, 300];
		const deepCopyArr = deepCopy(arr1, []);

		function deepCopy(arr, copiedArr) {
			if (arr.length === 0) {
				return copiedArr;
			}
			const [first, ...rest] = arr;
			if (Array.isArray(first)) {
				copiedArr.push(deepCopy(first, []));
			} else {
				copiedArr.push(first);
			}
			return deepCopy(rest, copiedArr);
		}
		console.log(deepCopyArr);
	</script>
</body>
</html>